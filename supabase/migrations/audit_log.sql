-- Create audit schema if not exists
create schema if not exists audit;

-- Create audit_log table for user/application actions
create table if not exists audit.audit_log (
  id bigserial primary key,
  user_id uuid not null references auth.users(id),
  event_type text not null,
  resource text not null,
  outcome text not null,
  metadata jsonb,
  created_at timestamptz not null default now()
);

-- Indexes for performance
create index if not exists audit_log_created_at_brin on audit.audit_log using brin(created_at);
create index if not exists audit_log_user_id_btree on audit.audit_log using btree(user_id);

-- Enable Row Level Security
alter table audit.audit_log enable row level security;

-- RLS Policies
-- Allow INSERT for service roles (replace 'service_role' with your actual role name)
create policy audit_log_insert on audit.audit_log
  for insert to authenticated
  with check (auth.uid() = user_id);

-- RBAC: Define roles and permissions
create type public.app_role as enum ('admin', 'auditor', 'user');
create type public.app_permission as enum ('audit_log.read');

-- User roles table
create table if not exists public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      public.app_role not null,
  unique (user_id, role)
);

-- Role permissions table
create table if not exists public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         public.app_role not null,
  permission   public.app_permission not null,
  unique (role, permission)
);

-- Helper function for RBAC in RLS
create or replace function public.authorize(requested_permission public.app_permission)
returns boolean as $$
declare
  bind_permissions int;
  user_role public.app_role;
begin
  select (auth.jwt() ->> 'user_role')::public.app_role into user_role;
  select count(*) into bind_permissions from public.role_permissions
    where role_permissions.permission = requested_permission and role_permissions.role = user_role;
  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = '';

-- Seed permissions: allow admin and auditor to read audit logs
insert into public.role_permissions (role, permission) values
  ('admin', 'audit_log.read'),
  ('auditor', 'audit_log.read')
on conflict do nothing;

-- Update SELECT policy to use RBAC
create policy audit_log_select_rbac on audit.audit_log
  for select to authenticated
  using (public.authorize('audit_log.read'));

-- Explicitly deny UPDATE and DELETE for all roles (defense-in-depth, clarity)
create policy audit_log_no_update on audit.audit_log
  for update to public
  using (false);

create policy audit_log_no_delete on audit.audit_log
  for delete to public
  using (false); 