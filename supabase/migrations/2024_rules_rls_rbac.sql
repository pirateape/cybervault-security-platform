-- Enable Row Level Security
alter table public.rules enable row level security;

-- RBAC/ENUM DEFENSIVE CREATION (for idempotency and migration order safety)
DO $$ BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_role') THEN
    CREATE TYPE public.app_role AS ENUM ('admin', 'auditor', 'user');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_permission') THEN
    CREATE TYPE public.app_permission AS ENUM ('rules.read', 'rules.create', 'rules.update', 'rules.delete');
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'user_roles') THEN
    CREATE TABLE public.user_roles (
      id        bigint generated by default as identity primary key,
      user_id   uuid references auth.users on delete cascade not null,
      role      public.app_role not null,
      unique (user_id, role)
    );
  END IF;
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'role_permissions') THEN
    CREATE TABLE public.role_permissions (
      id           bigint generated by default as identity primary key,
      role         public.app_role not null,
      permission   public.app_permission not null,
      unique (role, permission)
    );
  END IF;
END $$;

-- Add new permissions to app_permission enum if not already present
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM unnest(enum_range(NULL::public.app_permission)) v WHERE v = 'rules.read') THEN
    ALTER TYPE public.app_permission ADD VALUE 'rules.read';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM unnest(enum_range(NULL::public.app_permission)) v WHERE v = 'rules.create') THEN
    ALTER TYPE public.app_permission ADD VALUE 'rules.create';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM unnest(enum_range(NULL::public.app_permission)) v WHERE v = 'rules.update') THEN
    ALTER TYPE public.app_permission ADD VALUE 'rules.update';
  END IF;
  IF NOT EXISTS (SELECT 1 FROM unnest(enum_range(NULL::public.app_permission)) v WHERE v = 'rules.delete') THEN
    ALTER TYPE public.app_permission ADD VALUE 'rules.delete';
  END IF;
END$$;

-- Seed permissions for roles
insert into public.role_permissions (role, permission) values
  ('admin', 'rules.read'),
  ('admin', 'rules.create'),
  ('admin', 'rules.update'),
  ('admin', 'rules.delete'),
  ('auditor', 'rules.read'),
  ('user', 'rules.read'),
  ('user', 'rules.create')
on conflict do nothing;

-- SELECT policy: allow users with rules.read
create policy rules_select_rbac on public.rules
  for select to authenticated
  using (public.authorize('rules.read'));

-- INSERT policy: allow users with rules.create, and enforce created_by = auth.uid()
create policy rules_insert_rbac on public.rules
  for insert to authenticated
  with check (
    public.authorize('rules.create') and created_by = auth.uid()
  );

-- UPDATE policy: allow admins to update any, others only their own
create policy rules_update_admin on public.rules
  for update to authenticated
  using (
    public.authorize('rules.update') and (
      (select (auth.jwt() ->> 'user_role') = 'admin') or created_by = auth.uid()
    )
  );

-- DELETE policy: allow admins to delete any, others only their own
create policy rules_delete_admin on public.rules
  for delete to authenticated
  using (
    public.authorize('rules.delete') and (
      (select (auth.jwt() ->> 'user_role') = 'admin') or created_by = auth.uid()
    )
  );

-- Defense-in-depth: explicitly deny update/delete for all others
create policy rules_no_update on public.rules
  for update to public
  using (false);

create policy rules_no_delete on public.rules
  for delete to public
  using (false);

-- Index for RLS performance
create index if not exists idx_rules_created_by on public.rules(created_by); 